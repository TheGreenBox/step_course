digraph sat_step_ach {
    start="random";
    nodesep=0.3;
    bgcolor="transparent";
    node[shape=record, fontname="ISOCPEUR Italic", fontsize=28];
    edge[minlen=3];

    connection[shape=invhouse, label="Интерфейс связи"];
    {
        rank=same;
        moving_time[shape=ellipse, label="Заданное время движения"];
        speed[shape=ellipse, label="Заданная скорость"];
        goal_coord[shape=ellipse, label="Целевая точка"];
    }

    elementary_motions  [shape=box, label="Модуль дополнительных движений"];
    main                [shape=box, label="Главный цикл"];

    {
        rank=same;
        synchronized_control[shape=box, label="Модуль синхронного управления"];
        feedback_control    [shape=box, label="Модуль ОС по положению"];
        speed_feedback      [shape=box, label="Модуль ОС по скорости"];
    }

    {
        rank=same;
        current_feedback    [shape=box, label="Модуль ОС по току"];
        control_algo        [shape=box, label="Шаговый модуль"];
    }

    {
        // hardware level
        rank=same;
        timers              [shape=box, label="Модуль таймеров"];
        pwm_wrap_module     [shape=box, label="Модуль ШИМ"];
        init                [shape=box, label="Модуль инициализации"];
        adc                 [shape=box, label="Модуль АЦП"];
        led_control         [shape=box, label="Модуль работы со светодиодами"];
        uart                [shape=box, label="Модуль UART"];
        sensors_encoder     [shape=box, label="Модуль обработки прерываний энкодера"];
    }
    {
        rank=same;
        sensors_gray_code_decoder[shape=box, label="Модуль декодирования кода Грея"];
        algo_types          [shape=box, label="Библиотека алгоритмов переключения фаз ШД"];
    }

    main -> init;
    main -> led_control;
    main -> elementary_motions;

    uart -> connection;
    connection -> moving_time;
    connection -> speed;
    connection -> goal_coord;
    connection -> elementary_motions;

    speed       -> synchronized_control;
    goal_coord  -> synchronized_control;
    moving_time -> synchronized_control;

    speed       -> feedback_control;
    goal_coord  -> feedback_control;
    moving_time -> feedback_control;

    speed  -> speed_feedback;

    synchronized_control -> control_algo;
    feedback_control     -> control_algo;

    control_algo -> pwm_wrap_module;
    control_algo -> algo_types;

    timers -> synchronized_control;
    sensors_encoder -> feedback_control;

    elementary_motions -> moving_time;
    elementary_motions -> speed;
    elementary_motions -> goal_coord;

    speed_feedback -> current_feedback;
    adc ->  current_feedback;
    current_feedback -> pwm_wrap_module;

    sensors_encoder -> sensors_gray_code_decoder;
}

